# -*- coding: utf-8 -*-
"""track monster.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10QSpKRW--4OrLqx_mwzGXEs_uAlOzcqS
"""

# imports
import matplotlib.pyplot as plt
import matplotlib as mpl
from matplotlib.animation import FuncAnimation
from IPython.display import HTML
from scipy.interpolate import splprep, splev
import hashlib
import os
import cv2
import numpy as np
import time
from skimage.morphology import skeletonize
from matplotlib.transforms import Affine2D
import matplotlib.patches as patches

"""### Car on a simple circular path"""

# Simple circular track
# Reduced number of points to speed up animation generation
theta = np.linspace(0, 2*np.pi, 100) # Changed from 500 to 100 points
x = 100 + 80 * np.cos(theta)
y = 100 + 80 * np.sin(theta)

fig, ax = plt.subplots(figsize=(5,5))
ax.set_xlim(0, 200)
ax.set_ylim(0, 200)

# plot track
ax.plot(x, y, color='black')

# the "car"
dot, = ax.plot([], [], 'o', color='red', markersize=8)

def update(frame, x_data, y_data, artist):
  # The print statement is commented out to avoid excessive output during animation
  artist.set_data([x_data[frame]], [y_data[frame]])
  return artist,

ani = FuncAnimation(fig, update, frames=len(x), interval=10, fargs=(x, y, dot))

# Close the figure to prevent it from being displayed as a static image
plt.close(fig)

# # Display the animation in Colab
# HTML(ani.to_jshtml())

"""### Converting a png of a track"""

tracks_data = dict()

def track_details(filename):
  if filename not in tracks_data:
    tracks_data[filename] = {
        "name": None,
        "start_index": None,
        "direction": None,
        "track_scale": None,
        "geometry": {},
        "simulation_results": {}
    }

  # Ensure geometry and simulation_results dictionaries exist
  if "geometry" not in tracks_data[filename]:
    tracks_data[filename]["geometry"] = {}
  if "simulation_results" not in tracks_data[filename]:
    tracks_data[filename]["simulation_results"] = {}

  # Update track-specific details
  if filename == "gb.png":
    tracks_data[filename]["name"] = "Silverstone"
    tracks_data[filename]["start_index"] = 471
    tracks_data[filename]["direction"] = True
    tracks_data[filename]["track_scale"] = 1.5

  # Retrieve the updated details for return
  name = tracks_data[filename]["name"]
  start_index = tracks_data[filename]["start_index"]
  direction = tracks_data[filename]["direction"]
  track_scale = tracks_data[filename]["track_scale"]

  return name, start_index, direction, track_scale

filename = "gb.png"
smoothing_factor = 15000 # smoothing factor
total_path_vertices = 1500

"""### Cache Spline, Curvature into Geometry object"""

# Step 1: Load your track image (upload into Colab first)
img = cv2.imread(filename)
trackname, start_index, track_direction, track_scale = track_details(filename)
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# Step 2: Extract edges or threshold
edges = cv2.Canny(gray, 50, 150)

# Threshold then skeletonize
_, thresh = cv2.threshold(gray, 200, 255, cv2.THRESH_BINARY_INV)
skel = skeletonize(thresh // 255)

# Step 4: Extract the path points

# Helper to find neighbors of a point (y, x) in a skeleton
def get_neighbors(skel_image, y, x):
    neighbors = []
    for dy in [-1, 0, 1]:
        for dx in [-1, 0, 1]:
            if dy == 0 and dx == 0:
                continue
            ny, nx = y + dy, x + dx
            if 0 <= ny < skel_image.shape[0] and 0 <= nx < skel_image.shape[1] and skel_image[ny, nx]:
                neighbors.append((ny, nx))
    return neighbors

# Reorder the points for spline fitting
skel_points_list = [(p[0], p[1]) for p in np.column_stack(np.where(skel > 0))]
skel_points_set = set(skel_points_list) # For efficient lookup

ordered_pts_list = []

if skel_points_list:
    # Find a starting point (e.g., an endpoint with only one neighbor, or just the first point)
    start_point = None
    for p_y, p_x in skel_points_list:
        if len(get_neighbors(skel, p_y, p_x)) == 1:
            start_point = (p_y, p_x)
            break
    if start_point is None: # If no clear endpoint (e.g. a closed loop), pick the first point
        start_point = skel_points_list[0]

    current_point = start_point
    visited = {current_point}
    ordered_pts_list.append(current_point)

    # Traverse the skeleton to order points
    while len(ordered_pts_list) < len(skel_points_list):
        neighbors = get_neighbors(skel, current_point[0], current_point[1])
        next_point = None
        for n_y, n_x in neighbors:
            neighbor_tuple = (n_y, n_x)
            if neighbor_tuple not in visited and neighbor_tuple in skel_points_set:
                next_point = neighbor_tuple
                break
        if next_point:
            ordered_pts_list.append(next_point)
            visited.add(next_point)
            current_point = next_point
        else:
            # If we get stuck (e.g., a branch or discontinuity in the skeleton), break
            # For a single continuous path, this shouldn't be reached until all points are visited
            break

# Convert ordered points back to a NumPy array
pts = np.array(ordered_pts_list)

# Apply scaling to the points BEFORE spline fitting
pts_scaled = pts * track_scale

# Sort/fit a nice smooth spline along pts
tck, u = splprep([pts_scaled[:,1], pts_scaled[:,0]], s=smoothing_factor) # Use the scaled points
u_fine = np.linspace(0, 1, total_path_vertices) # Increased to 1000 points for better curvature detail
x_smooth, y_smooth = splev(u_fine, tck)

# Calculate cumulative path length from the already scaled x_smooth, y_smooth
distances = np.sqrt(np.diff(x_smooth)**2 + np.diff(y_smooth)**2)
cumulative_path_length = np.concatenate(([0.], np.cumsum(distances)))

# Calculate derivatives for curvature and heading
dx_du, dy_du = splev(u_fine, tck, der=1)
d2x_du2, d2y_du2 = splev(u_fine, tck, der=2)

# Calculate curvature
# Note: Curvature will be 1/track_scale * original_curvature if coordinates are scaled.
# This is physically correct for a scaled track.
curvature = (dx_du * d2y_du2 - dy_du * d2x_du2) / (dx_du**2 + dy_du**2)**1.5

# Calculate heading angles (tangent to the path) in degrees
headings_rad = np.arctan2(dy_du, dx_du)
headings_deg = np.degrees(headings_rad)

# Store all resulting geometry data into tracks_data[filename]['geometry']
# x_smooth, y_smooth, cumulative_path_length are already scaled by pts_scaled
tracks_data[filename]['geometry']['x_smooth'] = x_smooth
tracks_data[filename]['geometry']['y_smooth'] = y_smooth
tracks_data[filename]['geometry']['curvature'] = curvature
tracks_data[filename]['geometry']['cumulative_path_length'] = cumulative_path_length
tracks_data[filename]['geometry']['tck'] = tck
tracks_data[filename]['geometry']['u_fine'] = u_fine
tracks_data[filename]['geometry']['start_index'] = start_index
tracks_data[filename]['geometry']['headings_deg'] = headings_deg # Store heading degrees

print(f"Geometry data for {filename} (track '{trackname}') stored in tracks_data.")

"""### Helper Visualization for Track Initialization: Display Nth Point on Spline"""

def visualize_nth_point(n_point, x_data, y_data, track_image, title="Highlighted Point on Track"):
    if not (0 <= n_point < len(x_data)):
        print(f"Error: n_point ({n_point}) is out of bounds for data of length {len(x_data)}.")
        return

    fig, ax = plt.subplots(figsize=(10, 10))
    # Scale the image extent by track_scale to match the scaled x_data, y_data
    ax.imshow(track_image[...,::-1], extent=[0, track_image.shape[1] * track_scale, track_image.shape[0] * track_scale, 0])

    # Plot the full smoothed track
    ax.plot(x_data, y_data, 'b--', linewidth=1, alpha=0.7, label='Smoothed Track')

    # Highlight the nth point
    ax.plot(x_data[n_point], y_data[n_point], 'o', color='magenta', markersize=12, label=f'Point {n_point}', zorder=3)

    ax.set_title(title)
    ax.set_aspect('equal', adjustable='box')
    ax.legend()
    plt.show()

# Example usage: Visualize the starting point provided by track_details
# Ensure 'start_index' and 'x_smooth', 'y_smooth', 'img' are available from previous cells

# Assuming `start_index` is retrieved from `track_details` and `img` is the loaded track image
# If track_details returns 1, let's visualize index 1.
# You can change this to any index you want to inspect.

# Retrieve values from track_details
trackname_val, start_index_val, track_direction_val, track_scale_val = track_details(filename)

visualize_nth_point(start_index_val, x_smooth, y_smooth, img, title=f'Starting Point ({start_index_val}) for {trackname_val}')

# # Step 5: Animate a rectangle "car" moving along the spline
# fig, ax = plt.subplots(figsize=(6,6))
# ax.imshow(img[...,::-1])  # convert BGR -> RGB
# car, = ax.plot([], [], 's', markersize=10, color='red')

# # Define a simple update function locally for this animation
# def simple_update(frame, x_data, y_data, artist):
#   artist.set_data([x_data[frame]], [y_data[frame]])
#   return artist,

# plt.close(fig)
# ani = FuncAnimation(fig, simple_update, frames=len(x_smooth), interval=10, fargs=(x_smooth, y_smooth, car))

# HTML(ani.to_jshtml())

"""## Initialize Physics Model

"""

car_x = x_smooth[start_index]
car_y = y_smooth[start_index]
car_velocity = 0.0
car_acceleration = 0.0
dt = 0.05 # Time step for numerical integration

print(f"Car initialized at (x={car_x:.2f}, y={car_y:.2f}) with velocity={car_velocity:.2f} and acceleration={car_acceleration:.2f}. Time step dt={dt}.")

# Constants for physics model
max_base_speed = 365.0
min_curve_speed_factor = 100 # Higher means sharper corners need to be slower
min_speed_ratio = 0.1 # Minimum speed as a ratio of max_base_speed
max_acceleration = 60
max_braking_deceleration = 150
drag_coefficient = 0.0005
lookahead_indices = 120 # New parameter to control lookahead distance for predictive braking

def get_max_speed(current_curvature, max_base_speed, min_curve_speed_factor, min_speed_ratio):
    # Ensure curvature is positive for calculation
    abs_curvature = abs(current_curvature)

    # Use a non-linear term to adjust speed based on curvature
    # Power > 1 makes it less punitive at low curvature, more punitive at high curvature
    max_speed_unbounded = max_base_speed / (1 + abs_curvature**1.5 * min_curve_speed_factor)

    # Apply a minimum speed limit to prevent the car from stopping entirely
    max_speed = max(max_speed_unbounded, max_base_speed * min_speed_ratio)
    return max_speed

# Test the function with sample curvature values
sample_curvatures = [0, 0.01, 0.05, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.5] # More varied samples for testing

print("Testing get_max_speed function:")
for curv in sample_curvatures:
    speed = get_max_speed(curv, max_base_speed, min_curve_speed_factor, min_speed_ratio)
    print(f"  Curvature: {curv:.2f}, Max Speed: {speed:.2f}")

"""## Visualize Track Curvature"""

# Normalize curvature for coloring
# We'll take the absolute value of curvature, and then scale it.
# Clipping at a certain max value can make colors more distinct if there are extreme outliers.
abs_curvature = np.abs(curvature)
max_display_curvature = np.percentile(abs_curvature, 95) # Cap at 95th percentile to avoid outliers dominating
norm_curvature = np.clip(abs_curvature, 0, max_display_curvature) / max_display_curvature

# Choose a colormap: 'RdYlGn_r' is Red-Yellow-Green reversed, so green is low, red is high
cmap = plt.cm.get_cmap('RdYlGn_r')
colors = cmap(norm_curvature)

fig, ax = plt.subplots(figsize=(10, 10))
ax.imshow(img[...,::-1], extent=[0, img.shape[1] * track_scale, img.shape[0] * track_scale, 0]) # Ensure correct image orientation

# Plot the track points, colored by curvature
# Use scatter to color each point individually
scatter = ax.scatter(x_smooth, y_smooth, c=norm_curvature, cmap=cmap, s=20, zorder=2)

ax.set_title('Track Curvature Visualization (Green=Low, Red=High)')
ax.set_aspect('equal', adjustable='box')

# Add a colorbar
cbar = fig.colorbar(scatter, ax=ax, orientation='vertical', fraction=0.046, pad=0.04)
cbar.set_label('Normalized Absolute Curvature')

plt.show()

# Increase animation embed limit to allow larger animations
mpl.rcParams['animation.embed_limit'] = 200.0 # Set to 200 MB
redo_simulation = False

# --- Helper Functions for Caching and Simulation ---

def generate_sim_cache_key(physics_params):
    # Convert physics_params dictionary to a sorted string for consistent hashing
    sorted_params = sorted(physics_params.items())
    params_str = str(sorted_params)
    return hashlib.sha256(params_str.encode('utf-8')).hexdigest()

def simulate_car_trajectory(geometry_data, physics_params, num_frames=1080):
    # Extract geometry data
    x_smooth = geometry_data['x_smooth']
    y_smooth = geometry_data['y_smooth']
    curvature = geometry_data['curvature']
    cumulative_path_length = geometry_data['cumulative_path_length']
    tck = geometry_data['tck']
    u_fine = geometry_data['u_fine']
    start_index = geometry_data['start_index']
    headings_deg = geometry_data['headings_deg'] # New: Extract heading degrees
    total_track_length = cumulative_path_length[-1]

    # Extract physics parameters
    dt = physics_params['dt']
    max_base_speed = physics_params['max_base_speed']
    min_curve_speed_factor = physics_params['min_curve_speed_factor']
    min_speed_ratio = physics_params['min_speed_ratio']
    max_acceleration = physics_params['max_acceleration']
    max_braking_deceleration = physics_params['max_braking_deceleration']
    drag_coefficient = physics_params['drag_coefficient']
    lookahead_indices = physics_params['lookahead_indices'] # New parameter to control lookahead distance for predictive braking

    # Initialize local simulation state variables
    car_x_points = []
    car_y_points = []
    car_velocities_history = []
    car_headings_history = [] # New: Store car heading at each frame
    lap_times_with_frame = [] # Store (lap_duration, frame_completed) tuples

    car_current_index = start_index
    car_current_track_length = cumulative_path_length[start_index]
    car_velocity = 0.0
    car_acceleration = 0.0
    lap_count = 0
    lap_start_time = 0.0 # Will be updated when simulation starts

    # Simulation loop
    for frame in range(num_frames):
        # Get current curvature at the car's position
        current_curvature = curvature[car_current_index]

        # --- Predictive Braking Logic ---
        # Calculate minimum allowed speed within a lookahead window
        lookahead_window_start = car_current_index
        lookahead_window_end = min(car_current_index + lookahead_indices, len(curvature))
        # If we are near the end of the track, wrap around for lookahead if it's a continuous loop
        # For simplicity, we will just cap at the end of the track for now.

        # Get curvatures in the lookahead window
        lookahead_curvatures = curvature[lookahead_window_start:lookahead_window_end]

        # If the lookahead window is empty (e.g., at the very end of the track), default to current curvature
        if len(lookahead_curvatures) == 0:
            max_speed_in_lookahead = get_max_speed(current_curvature, max_base_speed, min_curve_speed_factor, min_speed_ratio)
        else:
            # Calculate max allowed speed for each point in the lookahead window
            max_speeds_in_window = [get_max_speed(c, max_base_speed, min_curve_speed_factor, min_speed_ratio) for c in lookahead_curvatures]
            # The minimum of these is the speed limit the car should anticipate
            max_speed_in_lookahead = np.min(max_speeds_in_window)

        # Determine desired acceleration based on current and predictive max speeds
        target_acceleration = 0.0

        # If car is currently faster than the upcoming speed limit, brake
        if car_velocity > max_speed_in_lookahead:
            target_acceleration = -max_braking_deceleration
        # Otherwise, accelerate up to the current max allowed speed (which might be higher than lookahead_speed)
        elif car_velocity < get_max_speed(current_curvature, max_base_speed, min_curve_speed_factor, min_speed_ratio):
            target_acceleration = max_acceleration

        # Calculate drag force (proportional to velocity squared)
        drag_force = drag_coefficient * car_velocity**2

        # Apply drag force to the acceleration
        car_acceleration = target_acceleration - drag_force

        # Clamp car_acceleration to respect max_acceleration limits
        # For now, we should accept that drag helps max_deceleration!
        car_acceleration = min(car_acceleration, max_acceleration)

        # Update car_velocity
        car_velocity += car_acceleration * dt
        # Clamp car_velocity to be non-negative (can't go backwards) and not exceed max_base_speed for safety
        # It should also not exceed max_speed_in_lookahead if we are braking for it, but the braking logic should handle that.
        car_velocity = max(0.0, min(car_velocity, max_base_speed))

        # Calculate distance moved
        distance_moved = car_velocity * dt

        # Update car_current_track_length
        car_current_track_length += distance_moved

        # Implement track looping and lap counting
        if car_current_track_length >= total_track_length:
            if lap_count == 0:
                # Initialize lap_start_time for the first lap, adjusting for initial track_length
                lap_start_time = frame * dt - (total_track_length - cumulative_path_length[start_index]) / car_velocity

            lap_duration = (frame * dt) - lap_start_time
            lap_times_with_frame.append(lap_duration) # Store just the duration
            print(f"Lap {lap_count + 1} completed in {lap_duration:.2f} seconds (frame {frame})")
            lap_start_time = frame * dt # Reset timer for next lap

            car_current_track_length -= total_track_length # Wrap around
            lap_count += 1

        # Find the new_car_current_index for curvature (nearest point on discrete path)
        new_car_current_index = np.searchsorted(cumulative_path_length, car_current_track_length, side='right') - 1
        car_current_index = max(0, min(new_car_current_index, len(x_smooth) - 1))

        # Calculate precise (x,y) on spline based on car_current_track_length
        current_u_value = np.interp(car_current_track_length, cumulative_path_length, u_fine)
        current_car_x, current_car_y = splev(current_u_value, tck)

        car_x_points.append(current_car_x)
        car_y_points.append(current_car_y)
        car_velocities_history.append(car_velocity)
        car_headings_history.append(headings_deg[car_current_index]) # New: Store heading

    return car_x_points, car_y_points, car_velocities_history, car_headings_history, lap_times_with_frame

# --- Simulation Caching Logic ---

# Get geometry data for the current filename
geometry_data = tracks_data[filename]['geometry']

# Create a dictionary of physics parameters for caching
physics_params = {
    'dt': dt,
    'max_base_speed': max_base_speed,
    'min_curve_speed_factor': min_curve_speed_factor,
    'min_speed_ratio': min_speed_ratio,
    'max_acceleration': max_acceleration,
    'max_braking_deceleration': max_braking_deceleration,
    'drag_coefficient': drag_coefficient,
    'lookahead_indices': lookahead_indices
}

sim_cache_key = generate_sim_cache_key(physics_params)

# Check if simulation results are cached
if not redo_simulation and sim_cache_key in tracks_data[filename]['simulation_results']:
    print("Loading simulation results from cache...")
    cached_sim_results = tracks_data[filename]['simulation_results'][sim_cache_key]
    trajectory_x = cached_sim_results['x']
    trajectory_y = cached_sim_results['y']
    trajectory_velocities = cached_sim_results['velocities']
    trajectory_headings = cached_sim_results['headings'] # New: retrieve headings
    final_lap_times = cached_sim_results['lap_times']
else:
    print("Simulating car trajectory...")
    trajectory_x, trajectory_y, trajectory_velocities, trajectory_headings, final_lap_times = simulate_car_trajectory(geometry_data, physics_params) # New: capture headings

    # Store results in cache
    tracks_data[filename]['simulation_results'][sim_cache_key] = {
        'x': trajectory_x,
        'y': trajectory_y,
        'velocities': trajectory_velocities,
        'headings': trajectory_headings, # New: store headings
        'lap_times': final_lap_times
    }
    print(f"Simulation completed. Cached with key: {sim_cache_key}")

# --- Simplified Update Function for Animation ---

def update(frame, car_artist, text_artist_speed, text_artist_lap, traj_x, traj_y, traj_velocities, traj_headings, lap_times_data, ax_transform):
    current_car_x = traj_x[frame]
    current_car_y = traj_y[frame]
    current_car_velocity = traj_velocities[frame]
    current_car_heading = traj_headings[frame] # New: get current heading

    # Update the car's position and rotation using an Affine2D transform
    # The Rectangle was created with its center at (0,0) (i.e., xy=(-width/2, -height/2))
    # So we apply a rotation around (0,0) then translate to the car's current position
    # The transform must be combined with the axis's data transform
    transform = Affine2D().rotate_deg(current_car_heading) + Affine2D().translate(current_car_x, current_car_y) + ax_transform
    car_artist.set_transform(transform)

    text_artist_speed.set_text(f'Speed: {current_car_velocity:.2f} units/s')

    # Display the most recent completed lap time up to the current frame
    # For this simplified display, we'll just show the latest completed lap time, if any.
    # If the simulation generated 'final_lap_times' it's the duration of completed laps.
    # We need to know which lap it is.
    if len(lap_times_data) > 0: # Check if any laps were completed
        current_lap_index = len(lap_times_data) - 1 # Get the last completed lap index
        current_lap_duration = lap_times_data[current_lap_index]
        text_artist_lap.set_text(f'Last Lap: {current_lap_duration:.2f}s')
    else:
        text_artist_lap.set_text('Laps: --')

    return car_artist, text_artist_speed, text_artist_lap

"""## Car Speed Profile Over Time (pre-animation sanity check)"""

fig, ax = plt.subplots(figsize=(12, 6))

# Create a time array for the x-axis (frames * dt)
time_steps = np.arange(len(trajectory_velocities)) * dt

ax.plot(time_steps, trajectory_velocities, label='Car Velocity')
ax.set_xlabel('Time (s)')
ax.set_ylabel('Velocity (units/s)')
ax.set_title('Car Velocity Profile Over Simulation Time')
ax.grid(True, linestyle='--', alpha=0.7)
ax.legend()

plt.tight_layout()
plt.show()

"""## Animation of Physics Model on Track"""

redo_simulation = False

# --- Animation Setup and FuncAnimation Call ---
fig, ax = plt.subplots(figsize=(8,8))
# Scale the image and set its extent
ax.imshow(img[...,::-1], extent=[0, img.shape[1] * track_scale, img.shape[0] * track_scale, 0])  # convert BGR -> RGB

# Plot the smoothed track
ax.plot(geometry_data['x_smooth'], geometry_data['y_smooth'], 'b--', linewidth=1, alpha=0.7)

# the "car" - now a rectangle patch that rotates
car_width, car_height = 50 * track_scale, 25 * track_scale # Define car size and apply track_scale
initial_x = geometry_data['x_smooth'][geometry_data['start_index']]
initial_y = geometry_data['y_smooth'][geometry_data['start_index']]
initial_heading = geometry_data['headings_deg'][geometry_data['start_index']]

# Create the rectangle with its center at (0,0), then apply transforms for position and rotation
car = patches.Rectangle(
    (-car_width / 2, -car_height / 2), # Centered at (0,0)
    car_width,
    car_height,
    facecolor='red',
    edgecolor='black',
    zorder=3 # Ensure car is drawn on top
)

# Apply initial transform to the car patch
initial_transform = Affine2D().rotate_deg(initial_heading) + Affine2D().translate(initial_x, initial_y) + ax.transData
car.set_transform(initial_transform)

ax.add_patch(car) # Add the car patch to the axes

# Add text for speed and lap time
text_speed = ax.text(0.05, 0.95, '', transform=ax.transAxes, color='black', fontsize=12, verticalalignment='top')
text_lap = ax.text(0.05, 0.90, '', transform=ax.transAxes, color='black', fontsize=12, verticalalignment='top')

# Determine number of frames for animation
num_animation_frames = len(trajectory_x)

ani = FuncAnimation(fig, update, frames=num_animation_frames, interval=20, blit=True, fargs=(
    car, text_speed, text_lap, trajectory_x, trajectory_y, trajectory_velocities, trajectory_headings, final_lap_times, ax.transData # Pass trajectory_headings and ax.transData
))

# Close the figure to prevent it from being displayed as a static image
plt.close(fig)
print("Animation prepared.")

output_filename = f"car_physics_animation_{sim_cache_key}.html"

# Check if the animation HTML file already exists
if os.path.exists(output_filename) and not redo_simulation:
    print(f"Reusing cached animation from {output_filename}")
    with open(output_filename, "r") as f:
        animation_html = f.read()
else:
    print(f"Generating and saving animation to {output_filename}")
    # Generate the HTML string for the animation
    animation_html = ani.to_jshtml()

    # Write the HTML string to a file
    with open(output_filename, "w") as f:
        f.write(animation_html)

print("You can download this file from the Colab file browser (left sidebar -> folder icon) and open it in any web browser.")

# Display the animation in Colab
HTML(animation_html)