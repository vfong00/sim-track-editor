# -*- coding: utf-8 -*-
"""track monster.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10QSpKRW--4OrLqx_mwzGXEs_uAlOzcqS
"""

# imports
import matplotlib.pyplot as plt
import matplotlib as mpl
from matplotlib.animation import FuncAnimation
from IPython.display import HTML
from scipy.interpolate import splprep, splev
import hashlib
import os
import cv2
import numpy as np
import time
from skimage.morphology import skeletonize
from matplotlib.transforms import Affine2D
import matplotlib.patches as patches
import matplotlib.colors as mcolors

"""## PNG conversion of track"""

tracks_data = dict()

def track_details(filename):
  if filename not in tracks_data:
    tracks_data[filename] = {
        "name": None,
        "start_index": None,
        "direction": None,
        "track_scale": None,
        "geometry": {},
        "simulation_results": {}
    }

  # Ensure geometry and simulation_results dictionaries exist
  if "geometry" not in tracks_data[filename]:
    tracks_data[filename]["geometry"] = {}
  if "simulation_results" not in tracks_data[filename]:
    tracks_data[filename]["simulation_results"] = {}

  # Update track-specific details
  if filename == "gb.png":
    tracks_data[filename]["name"] = "Silverstone"
    tracks_data[filename]["start_index"] = 471
    tracks_data[filename]["direction"] = True
    tracks_data[filename]["track_scale"] = 1.5
  elif filename == "yas marina.png":
    tracks_data[filename]["name"] = "Yas Marina"
    tracks_data[filename]["start_index"] = 1400
    tracks_data[filename]["direction"] = False
    tracks_data[filename]["track_scale"] = 1.5

  # Retrieve the updated details for return
  name = tracks_data[filename]["name"]
  start_index = tracks_data[filename]["start_index"]
  direction = tracks_data[filename]["direction"]
  track_scale = tracks_data[filename]["track_scale"]

  return name, start_index, direction, track_scale

filename = "yas marina.png"
smoothing_factor = 15000 # smoothing factor
total_path_vertices = 1500

"""## Cache splines and curvatures into Geometry objects"""

# Step 1: Load your track image (upload into Colab first)
img = cv2.imread(filename)
trackname, start_index, track_direction, track_scale = track_details(filename)
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# Step 2: Extract edges or threshold
edges = cv2.Canny(gray, 50, 150)

# Threshold then skeletonize
_, thresh = cv2.threshold(gray, 200, 255, cv2.THRESH_BINARY_INV)
skel = skeletonize(thresh // 255)

# Step 4: Extract the path points

# Helper to find neighbors of a point (y, x) in a skeleton
def get_neighbors(skel_image, y, x):
    neighbors = []
    for dy in [-1, 0, 1]:
        for dx in [-1, 0, 1]:
            if dy == 0 and dx == 0:
                continue
            ny, nx = y + dy, x + dx
            if 0 <= ny < skel_image.shape[0] and 0 <= nx < skel_image.shape[1] and skel_image[ny, nx]:
                neighbors.append((ny, nx))
    return neighbors

# Reorder the points for spline fitting
skel_points_list = [(p[0], p[1]) for p in np.column_stack(np.where(skel > 0))]
skel_points_set = set(skel_points_list) # For efficient lookup

ordered_pts_list = []

if skel_points_list:
    # Find a starting point (e.g., an endpoint with only one neighbor, or just the first point)
    start_point = None
    for p_y, p_x in skel_points_list:
        if len(get_neighbors(skel, p_y, p_x)) == 1:
            start_point = (p_y, p_x)
            break
    if start_point is None: # If no clear endpoint (e.g. a closed loop), pick the first point
        start_point = skel_points_list[0]

    current_point = start_point
    visited = {current_point}
    ordered_pts_list.append(current_point)

    # Traverse the skeleton to order points
    while len(ordered_pts_list) < len(skel_points_list):
        neighbors = get_neighbors(skel, current_point[0], current_point[1])
        next_point = None
        for n_y, n_x in neighbors:
            neighbor_tuple = (n_y, n_x)
            if neighbor_tuple not in visited and neighbor_tuple in skel_points_set:
                next_point = neighbor_tuple
                break
        if next_point:
            ordered_pts_list.append(next_point)
            visited.add(next_point)
            current_point = next_point
        else:
            # If we get stuck (e.g., a branch or discontinuity in the skeleton), break
            # For a single continuous path, this shouldn't be reached until all points are visited
            break

# Convert ordered points back to a NumPy array
pts = np.array(ordered_pts_list)

# Apply scaling to the points BEFORE spline fitting
pts_scaled = pts * track_scale

# --- Initial spline fitting and geometry calculation (natural direction) ---
tck_natural, u_fine_natural = splprep([pts_scaled[:,1], pts_scaled[:,0]], s=smoothing_factor)
x_smooth_natural, y_smooth_natural = splev(u_fine_natural, tck_natural)

distances_natural = np.sqrt(np.diff(x_smooth_natural)**2 + np.diff(y_smooth_natural)**2)
cumulative_path_length_natural = np.concatenate(([0.], np.cumsum(distances_natural)))

dx_du_natural, dy_du_natural = splev(u_fine_natural, tck_natural, der=1)
d2x_du2_natural, d2y_du2_natural = splev(u_fine_natural, tck_natural, der=2)

curvature_natural = (dx_du_natural * d2y_du2_natural - dy_du_natural * d2x_du2_natural) / (dx_du_natural**2 + dy_du_natural**2)**1.5

headings_rad_natural = np.arctan2(dy_du_natural, dx_du_natural)
headings_deg_natural = np.degrees(headings_rad_natural)

# --- Conditional Reversal Logic ---
if not track_direction: # If track_direction is False, reverse the path
    print(f"Reversing track direction for {filename}.")

    # Reverse the order of points for spline fitting
    pts_scaled_reversed = pts_scaled[::-1]

    # Re-fit spline for the reversed path
    tck_reversed, u_fine_reversed = splprep([pts_scaled_reversed[:,1], pts_scaled_reversed[:,0]], s=smoothing_factor)
    x_smooth, y_smooth = splev(u_fine_reversed, tck_reversed)

    # Recalculate geometry for the reversed path
    distances = np.sqrt(np.diff(x_smooth)**2 + np.diff(y_smooth)**2)
    cumulative_path_length = np.concatenate(([0.], np.cumsum(distances)))

    dx_du, dy_du = splev(u_fine_reversed, tck_reversed, der=1)
    d2x_du2, d2y_du2 = splev(u_fine_reversed, tck_reversed, der=2)

    curvature = (dx_du * d2y_du2 - dy_du * d2x_du2) / (dx_du**2 + dy_du**2)**1.5

    headings_rad = np.arctan2(dy_du, dx_du)
    headings_deg = np.degrees(headings_rad)

    # Adjust start_index for the reversed path
    start_index = (len(x_smooth) - 1 - start_index)
    start_index = max(0, min(start_index, len(x_smooth) - 1)) # Ensure valid index

    # Assign reversed tck and u_fine
    tck = tck_reversed
    u_fine = u_fine_reversed

else:
    # If not reversed, use the natural calculations
    x_smooth = x_smooth_natural
    y_smooth = y_smooth_natural
    cumulative_path_length = cumulative_path_length_natural
    curvature = curvature_natural
    headings_deg = headings_deg_natural
    tck = tck_natural
    u_fine = u_fine_natural

# Store all resulting geometry data into tracks_data[filename]['geometry']
tracks_data[filename]['geometry']['x_smooth'] = x_smooth
tracks_data[filename]['geometry']['y_smooth'] = y_smooth
tracks_data[filename]['geometry']['curvature'] = curvature
tracks_data[filename]['geometry']['cumulative_path_length'] = cumulative_path_length
tracks_data[filename]['geometry']['tck'] = tck
tracks_data[filename]['geometry']['u_fine'] = u_fine
tracks_data[filename]['geometry']['start_index'] = start_index # Store the potentially adjusted start_index
tracks_data[filename]['geometry']['headings_deg'] = headings_deg # Store heading degrees

print(f"Geometry data for {filename} (track '{trackname}') stored in tracks_data.")

"""### Diagnostic Display Nth Point on Spline"""

def visualize_nth_point(n_point, x_data, y_data, track_image, title="Highlighted Point on Track"):
    if not (0 <= n_point < len(x_data)):
        print(f"Error: n_point ({n_point}) is out of bounds for data of length {len(x_data)}.")
        return

    fig, ax = plt.subplots(figsize=(10, 10))
    # Scale the image extent by track_scale to match the scaled x_data, y_data
    ax.imshow(track_image[...,::-1], extent=[0, track_image.shape[1] * track_scale, track_image.shape[0] * track_scale, 0])

    # Plot the full smoothed track
    ax.plot(x_data, y_data, 'b--', linewidth=1, alpha=0.7, label='Smoothed Track')

    # Highlight the nth point
    ax.plot(x_data[n_point], y_data[n_point], 'o', color='magenta', markersize=12, label=f'Point {n_point}', zorder=3)

    ax.set_title(title)
    ax.set_aspect('equal', adjustable='box')
    ax.legend()
    plt.show()

# Example usage: Visualize the starting point provided by track_details
# Ensure 'start_index' and 'x_smooth', 'y_smooth', 'img' are available from previous cells

# Assuming `start_index` is retrieved from `track_details` and `img` is the loaded track image
# If track_details returns 1, let's visualize index 1.
# You can change this to any index you want to inspect.

# Retrieve values from track_details
trackname_val, start_index_val, track_direction_val, track_scale_val = track_details(filename)
visualize_nth_point(start_index_val, x_smooth, y_smooth, img, title=f'Starting Point ({start_index_val}) for {trackname_val}')

"""## Initialize Physics Model

### Implement Braking Distance Calculation

### Subtask:
Create a function `calculate_braking_distance(initial_velocity, target_velocity, max_deceleration, drag_coefficient)` that accurately calculates the distance required to slow down from `initial_velocity` to `target_velocity`, considering `max_deceleration` and `drag_coefficient`. This will involve solving the integral ds = v * dv / (-max_deceleration - drag_coefficient * v^2).

#### Instructions
1. Define a Python function named `calculate_braking_distance` that accepts four arguments: `initial_velocity`, `target_velocity`, `max_deceleration`, and `drag_coefficient`.
2. Inside the function, implement the analytical solution for the braking distance by integrating the formula `ds = v * dv / (-max_deceleration - drag_coefficient * v^2)` from `initial_velocity` to `target_velocity`.
3. Make sure to handle edge cases such as `target_velocity` being greater than or equal to `initial_velocity` (in which case braking distance should be 0 or negative, or an error should be returned), or parameters that might lead to division by zero or non-real results.
4. Return the calculated braking distance.
"""

car_x = x_smooth[start_index]
car_y = y_smooth[start_index]
car_velocity = 0.0
car_acceleration = 0.0
dt = 0.05 # Time step for numerical integration

print(f"Car initialized at (x={car_x:.2f}, y={car_y:.2f}) with velocity={car_velocity:.2f} and acceleration={car_acceleration:.2f}. Time step dt={dt}.")

# Constants for physics model
max_base_speed = 365.0
min_curve_speed_factor = 2_000
min_speed_ratio = 0.135 # Minimum speed as a ratio of max_base_speed
max_acceleration = 52
max_braking_deceleration = 80
drag_coefficient = 0.0005
dt = 0.05 # Time step for numerical integration

def get_max_speed(current_curvature, max_base_speed, min_curve_speed_factor, min_speed_ratio):
    # Ensure curvature is positive for calculation
    abs_curvature = abs(current_curvature)

    # Use a non-linear term to adjust speed based on curvature
    # Power > 1 makes it less punitive at low curvature, more punitive at high curvature
    max_speed_unbounded = max_base_speed / (1 + abs_curvature**1.8 * min_curve_speed_factor)

    # Apply a minimum speed limit to prevent the car from stopping entirely
    max_speed = max(max_speed_unbounded, max_base_speed * min_speed_ratio)
    return max_speed

def calculate_braking_distance(initial_velocity, target_velocity, max_deceleration, drag_coefficient):
    """
    Calculates the distance required to slow down from initial_velocity to target_velocity,
    considering max_deceleration and drag_coefficient.

    Args:
        initial_velocity (float): The car's initial speed.
        target_velocity (float): The desired final speed.
        max_deceleration (float): The maximum braking deceleration (positive value).
        drag_coefficient (float): The drag coefficient (positive or zero).

    Returns:
        float: The calculated braking distance. Returns 0 if initial_velocity <= target_velocity
               or if any parameter is invalid. Returns np.inf if target_velocity cannot be reached
               (e.g., trying to brake to a speed below what drag allows if drag_coefficient is 0).
    """

    # Input validation and edge cases
    if initial_velocity < 0 or target_velocity < 0 or max_deceleration <= 0 or drag_coefficient < 0:
        print("Error: All velocities must be non-negative, max_deceleration must be positive, and drag_coefficient non-negative.")
        return 0.0

    if target_velocity >= initial_velocity:
        return 0.0 # No braking distance needed or impossible to reach higher speed by braking

    # Case 1: No drag (drag_coefficient is 0)
    if drag_coefficient == 0:
        # Simple kinematic equation: v_f^2 = v_i^2 + 2*a*s => s = (v_f^2 - v_i^2) / (2*a)
        # Here, a = -max_deceleration
        braking_distance = (target_velocity**2 - initial_velocity**2) / (2 * -max_deceleration)
        return braking_distance # Return positive distance directly

    # Case 2: With drag (drag_coefficient > 0)
    try:
        # The formula derived from integrating ds = v dv / (-D - c v^2)
        # where D = max_deceleration, c = drag_coefficient
        # S = (1 / (2*c)) * ln( (D + c * v_i^2) / (D + c * v_f^2) )

        numerator_term = max_deceleration + drag_coefficient * initial_velocity**2
        denominator_term = max_deceleration + drag_coefficient * target_velocity**2

        if denominator_term <= 0 or numerator_term <= 0: # Should not happen with positive D, c, v^2
            # This case indicates that the target velocity is unreachable or the formula is misused.
            # For example, if target_velocity is too low that drag alone is greater than deceleration.
            print("Error: Logarithm argument non-positive, check parameters or target_velocity.")
            return np.inf # Return infinity if target is unreachable

        braking_distance = (1 / (2 * drag_coefficient)) * np.log(numerator_term / denominator_term)
        return braking_distance
    except Exception as e:
        print(f"An error occurred during braking distance calculation: {e}")
        return 0.0

print("--- Re-testing calculate_braking_distance after fix ---")

# Test Case 1: Braking to a stop with drag
initial_v1 = 100.0
target_v1 = 0.0
max_decel1 = 80.0
drag_c1 = 0.0005
dist1 = calculate_braking_distance(initial_v1, target_v1, max_decel1, drag_c1)
print(f"Initial V: {initial_v1}, Target V: {target_v1}, Decel: {max_decel1}, Drag: {drag_c1} => Distance: {dist1:.2f}")

# Test Case 2: Braking to a stop without drag (should now be positive)
initial_v2 = 100.0
target_v2 = 0.0
max_decel2 = 80.0
drag_c2 = 0.0 # No drag
dist2 = calculate_braking_distance(initial_v2, target_v2, max_decel2, drag_c2)
print(f"Initial V: {initial_v2}, Target V: {target_v2}, Decel: {max_decel2}, Drag: {drag_c2} => Distance: {dist2:.2f}")

# Test Case 3: Braking from a high speed to a lower speed with drag
initial_v3 = 150.0
target_v3 = 50.0
max_decel3 = 80.0
drag_c3 = 0.0005
dist3 = calculate_braking_distance(initial_v3, target_v3, max_decel3, drag_c3)
print(f"Initial V: {initial_v3}, Target V: {target_v3}, Decel: {max_decel3}, Drag: {drag_c3} => Distance: {dist3:.2f}")

# Test Case 4: Target velocity >= initial velocity (should return 0)
initial_v4 = 50.0
target_v4 = 50.0
max_decel4 = 80.0
drag_c4 = 0.0005
dist4 = calculate_braking_distance(initial_v4, target_v4, max_decel4, drag_c4)
print(f"Initial V: {initial_v4}, Target V: {target_v4}, Decel: {max_decel4}, Drag: {drag_c4} => Distance: {dist4:.2f} (Expected: 0.00)")

# Test Case 5: Target velocity > initial velocity (should return 0)
initial_v5 = 50.0
target_v5 = 70.0
max_decel5 = 80.0
drag_c5 = 0.0005
dist5 = calculate_braking_distance(initial_v5, target_v5, max_decel5, drag_c5)
print(f"Initial V: {initial_v5}, Target V: {target_v5}, Decel: {max_decel5}, Drag: {drag_c5} => Distance: {dist5:.2f} (Expected: 0.00)")

# Test Case 6: Invalid input (negative velocity, should return 0 and print error)
initial_v6 = -10.0
target_v6 = 0.0
max_decel6 = 80.0
drag_c6 = 0.0005
dist6 = calculate_braking_distance(initial_v6, target_v6, max_decel6, drag_c6)
print(f"Initial V: {initial_v6}, Target V: {target_v6}, Decel: {max_decel6}, Drag: {drag_c6} => Distance: {dist6:.2f} (Expected: 0.00 and Error)")

# Test Case 7: Invalid input (zero deceleration, should return 0 and print error)
initial_v7 = 100.0
target_v7 = 0.0
max_decel7 = 0.0
drag_c7 = 0.0005
dist7 = calculate_braking_distance(initial_v7, target_v7, max_decel7, drag_c7)
print(f"Initial V: {initial_v7}, Target V: {target_v7}, Decel: {max_decel7}, Drag: {drag_c7} => Distance: {dist7:.2f} (Expected: 0.00 and Error)")

"""### Theoretical Acceleration and Braking Times (Factoring in Drag)"""

# Target speed for acceleration/braking test
target_speed = 300.0 # units/second

# --- Acceleration with Drag ---
# dv/dt = max_acceleration - drag_coefficient * v^2
# Integral of dv / (a - c*v^2) from 0 to target_speed
# Result is 1/(2*sqrt(ac)) * ln |(sqrt(a) + v*sqrt(c)) / (sqrt(a) - v*sqrt(c))|

a = max_acceleration
c = drag_coefficient

# Check for potential division by zero or negative argument in sqrt/log
if a * c <= 0 or (np.sqrt(a) - target_speed * np.sqrt(c)) <= 0:
    print("Cannot calculate acceleration time with drag using this formula (parameters lead to singularity or imaginary numbers).")
    print("This could mean target_speed is too high for given max_acceleration and drag, or parameters are zero.")
    time_to_accelerate_drag = np.inf
else:
    term_sqrt_ac = np.sqrt(a * c)
    term_sqrt_a = np.sqrt(a)
    term_sqrt_c = np.sqrt(c)

    # Ensure the argument for log is positive
    numerator = term_sqrt_a + target_speed * term_sqrt_c
    denominator = term_sqrt_a - target_speed * term_sqrt_c

    if denominator <= 0: # This means the car cannot reach target_speed due to drag limiting top speed
        print(f"Warning: Car's top speed ({term_sqrt_a / term_sqrt_c:.2f} units/s) is less than target_speed ({target_speed:.2f} units/s) with current drag/acceleration.")
        time_to_accelerate_drag = np.inf # Car can't reach this speed
    else:
        time_to_accelerate_drag = (1 / (2 * term_sqrt_ac)) * np.log(numerator / denominator)


# --- Braking with Drag ---
# dv/dt = -max_braking_deceleration - drag_coefficient * v^2
# Integral of -dv / (d + c*v^2) from target_speed to 0
# Result is 1/sqrt(dc) * (arctan(v0*sqrt(c/d)) - arctan(vf*sqrt(c/d)))
# For braking to 0, vf=0, so arctan(0) = 0.

d = max_braking_deceleration
c = drag_coefficient

if d * c <= 0:
    print("Cannot calculate braking time with drag using this formula (parameters lead to singularity). Parameters might be zero.")
    time_to_brake_drag = np.inf
else:
    term_sqrt_dc = np.sqrt(d * c)
    term_sqrt_c_div_d = np.sqrt(c / d)
    time_to_brake_drag = (1 / term_sqrt_dc) * np.arctan(target_speed * term_sqrt_c_div_d)

print(f"Time to accelerate from 0 to {target_speed:.2f} units/s (with drag): {time_to_accelerate_drag:.2f} seconds")
print(f"Time to brake from {target_speed:.2f} units/s to 0 (with drag): {time_to_brake_drag:.2f} seconds")

# For comparison, re-print values without drag (from cell be7cdcf9)
# time_to_accelerate_no_drag = target_speed / max_acceleration
# time_to_brake_no_drag = target_speed / max_braking_deceleration
# print(f"For comparison, without drag: Acceleration Time: {time_to_accelerate_no_drag:.2f}s, Braking Time: {time_to_brake_no_drag:.2f}s")

"""### Max speed vs curvature"""

# --- Plotting the sample curvatures vs speeds ---
curvature_range = np.linspace(0, 0.04, 1000) # From 0 to 0.05 with 500 points

# Calculate max speed for each curvature in the range
max_speeds_for_range = [
    get_max_speed(curv, max_base_speed, min_curve_speed_factor, min_speed_ratio)
    for curv in curvature_range
]

fig, ax = plt.subplots(figsize=(12, 6))

ax.plot(curvature_range, max_speeds_for_range, linestyle='-', color='blue')

min_allowed_speed = min_speed_ratio * max_base_speed
ax.axhline(y=min_allowed_speed, color='red', linestyle='--', label=f'Min Allowed Speed ({min_allowed_speed:.2f})')

ax.set_xlabel('Curvature Magnitude')
ax.set_ylabel('Maximum Allowed Speed (units/s)')
ax.set_title(f'Maximum Allowed Speed vs. Curvature (min_curve_speed_factor={min_curve_speed_factor})')
ax.grid(True, linestyle='--', alpha=0.7)

plt.tight_layout()
plt.show()
# --- End plotting ---

"""## Track diagnostic visualizations

### Track speed limits map
"""

def calculate_max_entry_speed(target_velocity, braking_distance, max_deceleration, drag_coefficient):
    """
    Calculates the maximum initial speed a car can have to brake to target_velocity
    within a given braking_distance. (Reverse of calculate_braking_distance)

    Args:
        target_velocity (float): The desired final speed.
        braking_distance (float): The distance over which to brake.
        max_deceleration (float): The maximum braking deceleration (positive value).
        drag_coefficient (float): The drag coefficient (positive or zero).

    Returns:
        float: The maximum initial speed. Returns np.inf if not constrained by braking.
               Returns target_velocity if braking_distance is 0.
    """
    if braking_distance <= 0:
        return target_velocity # If no distance to brake, max entry speed is the target speed

    if drag_coefficient == 0:
        # v_i^2 = v_f^2 + 2*a*s => v_i^2 = v_f^2 + 2 * max_deceleration * S
        # Note: here 'a' is deceleration, so it's positive in this context.
        # Ensure argument to sqrt is non-negative
        arg = target_velocity**2 + 2 * max_deceleration * braking_distance
        return np.sqrt(max(0.0, arg))
    else:
        try:
            D = max_deceleration
            c = drag_coefficient
            S = braking_distance
            v_f = target_velocity

            term_exp = np.exp(2 * c * S)
            numerator_term = term_exp * (D + c * v_f**2) - D

            if numerator_term < 0: # This can happen if target_velocity is too high or braking_distance too short
                return 0.0 # Cannot reach this speed, or physically impossible to slow down
            return np.sqrt(numerator_term / c)
        except Exception as e:
            print(f"Error in calculate_max_entry_speed with drag: {e}")
            return max_base_speed # Fallback to max_base_speed if calculation fails (effectively unconstrained)



# Define a lookahead_distance_factor for this visualization
lookahead_distance_factor_viz = 2.0 # Similar to the one used in simulation

# Calculate anticipated max speed for each point based on the dynamic lookahead window
anticipated_max_speeds_for_plotting = []
num_track_points = len(tracks_data[filename]['geometry']['curvature'])
total_track_length = tracks_data[filename]['geometry']['cumulative_path_length'][-1]
cumulative_path_length = tracks_data[filename]['geometry']['cumulative_path_length']

for i in range(num_track_points):
    current_pos_on_track = cumulative_path_length[i]
    current_curvature = tracks_data[filename]['geometry']['curvature'][i]
    max_speed_at_current_point_from_curvature = get_max_speed(current_curvature, max_base_speed, min_curve_speed_factor, min_speed_ratio)

    # Initialize with the maximum possible speed at current point based on its curvature
    effective_max_speed_at_current_point = max_speed_at_current_point_from_curvature

    # The lookahead distance for visualization should reflect how far the car *would* look ahead
    # to plan braking. Let's use max_base_speed to define this lookahead for plotting purposes.
    dynamic_lookahead_distance = max_base_speed * lookahead_distance_factor_viz

    # Find the next critical point (point with lowest speed limit) within the lookahead
    min_speed_in_lookahead_future = max_base_speed
    distance_to_critical_point = 0.0
    found_critical_point = False

    for k in range(1, num_track_points): # Start from the next point (k=1) relative to 'i'
        idx = (i + k) % num_track_points

        dist_along_track_to_idx = cumulative_path_length[idx]

        if dist_along_track_to_idx >= current_pos_on_track:
            distance_from_current_point_to_idx = dist_along_track_to_idx - current_pos_on_track
        else: # Wrap around case
            distance_from_current_point_to_idx = (total_track_length - current_pos_on_track) + dist_along_track_to_idx

        # Break if we exceed the dynamic lookahead distance
        if distance_from_current_point_to_idx > dynamic_lookahead_distance:
            break

        max_allowed_speed_at_idx = get_max_speed(
            tracks_data[filename]['geometry']['curvature'][idx],
            max_base_speed,
            min_curve_speed_factor,
            min_speed_ratio
        )

        # Update the minimum speed found in the lookahead window
        if max_allowed_speed_at_idx < min_speed_in_lookahead_future:
            min_speed_in_lookahead_future = max_allowed_speed_at_idx
            distance_to_critical_point = distance_from_current_point_to_idx
            found_critical_point = True

    # If a critical point with a lower speed limit was found, calculate the max speed the car
    # could be at the *current* point 'i' to be able to brake to that future speed limit.
    if found_critical_point and distance_to_critical_point > 0:
        max_speed_from_braking_consideration = calculate_max_entry_speed(
            min_speed_in_lookahead_future,
            distance_to_critical_point,
            max_braking_deceleration,
            drag_coefficient
        )
        effective_max_speed_at_current_point = min(effective_max_speed_at_current_point, max_speed_from_braking_consideration)

    # Also, ensure we don't exceed the global max_base_speed
    effective_max_speed_at_current_point = min(effective_max_speed_at_current_point, max_base_speed)

    anticipated_max_speeds_for_plotting.append(effective_max_speed_at_current_point)

anticipated_max_speeds_for_plotting = np.array(anticipated_max_speeds_for_plotting)

# Choose a colormap: 'RdYlGn' (Red-Yellow-Green) is good, with Red for low speed, Green for high speed.
cmap = mpl.colormaps['RdYlGn'] # Updated to use matplotlib.colormaps

fig, ax = plt.subplots(figsize=(10, 10))
ax.imshow(img[...,::-1], extent=[0, img.shape[1] * track_scale, img.shape[0] * track_scale, 0])

# Plot the track points, colored by anticipated maximum allowed speed with linear scale
scatter = ax.scatter(
    x_smooth, y_smooth,
    c=anticipated_max_speeds_for_plotting,
    cmap=cmap,
    s=20,
    zorder=2
)

ax.set_title(f'Track Anticipated Max Speed Visualization (Dynamic Lookahead: {lookahead_distance_factor_viz}xMaxSpeed)')
ax.set_aspect('equal', adjustable='box')

# Add a colorbar
cbar = fig.colorbar(scatter, ax=ax, orientation='vertical', fraction=0.046, pad=0.04)
cbar.set_label('Anticipated Maximum Allowed Speed (units/s)')

plt.show()

"""### Track curvatures map"""

# Ensure `curvature`, `x_smooth`, `y_smooth`, `img`, `track_scale` are available from previous cells
# Use absolute curvature to represent magnitude on the map
abs_curvature = np.abs(tracks_data[filename]['geometry']['curvature'])

# Choose a colormap: 'viridis' as requested
cmap = mpl.colormaps['RdYlGn_r'] # Using 'viridis' for a smooth gradient

fig, ax = plt.subplots(figsize=(10, 10))
ax.imshow(img[...,::-1], extent=[0, img.shape[1] * track_scale, img.shape[0] * track_scale, 0])

# Plot the track points, colored by absolute curvature magnitude
scatter = ax.scatter(
    x_smooth, y_smooth,
    c=abs_curvature,
    cmap=cmap,
    s=20, # Size of markers
    zorder=2, # Ensure dots are on top of the image
    norm=mpl.colors.SymLogNorm(linthresh=0.01, vmin=abs_curvature.min(), vmax=abs_curvature.max()) # Use SymLogNorm with linthresh=0.01
)

ax.set_title('Track Curvature Map (SymLogNorm with linthresh=0.01: Emphasizing Curvature > 0.01)')
ax.set_aspect('equal', adjustable='box')

# Add a colorbar
cbar = fig.colorbar(scatter, ax=ax, orientation='vertical', fraction=0.046, pad=0.04)
cbar.set_label('Absolute Curvature Magnitude')

plt.show()

"""### Track curvatures vs index


"""

import numpy as np

# Assuming 'curvature' array and 'start_index' are available from previous cells
# Use absolute curvature to represent magnitude
abs_curvature = np.abs(tracks_data[filename]['geometry']['curvature'])
start_index_for_plot = tracks_data[filename]['geometry']['start_index']

# Reorder abs_curvature to start from start_index and loop around
abs_curvature_reordered = np.roll(abs_curvature, -start_index_for_plot)

fig, ax = plt.subplots(figsize=(15, 6))

# Plot reordered curvature magnitude against point index
ax.plot(abs_curvature_reordered)

ax.set_xlabel('Track Point Index (starting from track\'s start_index)')
ax.set_ylabel('Absolute Curvature Magnitude')
ax.set_title('Track Curvature Magnitude Across Points (reordered from start_index)')
ax.grid(True, linestyle='--', alpha=0.7)

plt.tight_layout()
plt.show()

"""## Track simulation and caching

### Simulation
"""

def generate_sim_cache_key(physics_params, filename):
    # Convert physics_params dictionary to a sorted string for consistent hashing
    sorted_params = sorted(physics_params.items())
    # Include filename in the string to be hashed
    params_and_filename_str = str(sorted_params) + filename
    return hashlib.sha256(params_and_filename_str.encode('utf-8')).hexdigest()

mpl.rcParams['animation.embed_limit'] = 300.0 # Raise to 300 MB
redo_simulation = False # Ensure simulation is re-run with new logic

def simulate_car_trajectory(geometry_data, physics_params, num_frames=1765):
    # Extract geometry data
    x_smooth = geometry_data['x_smooth']
    y_smooth = geometry_data['y_smooth']
    curvature = geometry_data['curvature']
    cumulative_path_length = geometry_data['cumulative_path_length']
    tck = geometry_data['tck']
    u_fine = geometry_data['u_fine']
    start_index = geometry_data['start_index']
    headings_deg = geometry_data['headings_deg'] # New: Extract heading degrees
    total_track_length = cumulative_path_length[-1]

    # Extract physics parameters
    dt = physics_params['dt']
    max_base_speed = physics_params['max_base_speed']
    min_curve_speed_factor = physics_params['min_curve_speed_factor']
    min_speed_ratio = physics_params['min_speed_ratio']
    max_acceleration = physics_params['max_acceleration']
    max_braking_deceleration = physics_params['max_braking_deceleration']
    drag_coefficient = physics_params['drag_coefficient']
    lookahead_distance_factor = physics_params['lookahead_distance_factor'] # New parameter

    # Initialize local simulation state variables
    car_x_points = []
    car_y_points = []
    car_velocities_history = []
    car_headings_history = [] # Store car heading at each frame
    lap_durations = [] # Store lap durations
    lap_completion_frames = [] # Store the frame index when each lap was completed

    # Car state variables
    car_odometer_distance = 0.0 # Total distance traveled by the car since the start of simulation
    car_velocity = 0.0
    car_acceleration = 0.0

    # Lap timing specific variables
    # We define the start line as the position corresponding to start_index
    start_line_absolute_position = cumulative_path_length[start_index]
    last_lap_completion_time = 0.0 # Time when the last lap was completed
    laps_recorded = 0

    # Simulation loop
    for frame in range(num_frames):
        # Calculate current position on the track loop based on odometer and initial start_index offset
        # This ensures the car's position on the track accurately reflects a continuous loop
        current_pos_on_loop = (start_line_absolute_position + car_odometer_distance) % total_track_length

        # Find the new_car_current_index for curvature (nearest point on discrete path)
        new_car_current_index = np.searchsorted(cumulative_path_length, current_pos_on_loop, side='right') - 1
        car_current_index = max(0, min(new_car_current_index, len(x_smooth) - 1))

        # Get current curvature at the car's position
        current_curvature = curvature[car_current_index]

        # --- Predictive Braking Logic (Dynamic Lookahead) ---
        dynamic_lookahead_distance = car_velocity * lookahead_distance_factor

        min_speed_in_lookahead = max_base_speed
        distance_to_critical_point = np.inf

        # Iterate through points ahead of the car
        for k in range(len(curvature)): # Iterate up to all points, will break if distance exceeded
            idx = (car_current_index + k) % len(curvature)

            # Calculate distance from car to this point 'idx'
            dist_along_track_to_idx = cumulative_path_length[idx]

            if dist_along_track_to_idx >= current_pos_on_loop:
                distance_from_car = dist_along_track_to_idx - current_pos_on_loop
            else: # Wrap around case
                distance_from_car = (total_track_length - current_pos_on_loop) + dist_along_track_to_idx

            if distance_from_car > dynamic_lookahead_distance and k > 0: # Only break if we've moved past the first point and exceeded lookahead
                break

            max_allowed_speed_at_idx = get_max_speed(curvature[idx], max_base_speed, min_curve_speed_factor, min_speed_ratio)

            if max_allowed_speed_at_idx < min_speed_in_lookahead:
                min_speed_in_lookahead = max_allowed_speed_at_idx
                distance_to_critical_point = distance_from_car

        # If no critical point was found (e.g., very short lookahead, flat track), default to current point's max speed
        if distance_to_critical_point == np.inf:
            max_speed_in_lookahead = get_max_speed(current_curvature, max_base_speed, min_curve_speed_factor, min_speed_ratio)
            distance_to_critical_point = 0.0 # Effectively no braking needed for upcoming turns
        else:
            max_speed_in_lookahead = min_speed_in_lookahead

        # Determine desired acceleration based on current and predictive max speeds
        target_acceleration = 0.0 # Default to coasting

        current_max_allowed_speed_at_point = get_max_speed(current_curvature, max_base_speed, min_curve_speed_factor, min_speed_ratio)

        # Calculate required braking distance to slow down from current velocity to the future minimum speed
        required_braking_distance = calculate_braking_distance(
            car_velocity,
            min_speed_in_lookahead, # Use min_speed_in_lookahead as the target velocity for braking
            max_braking_deceleration,
            drag_coefficient
        )

        # Apply intelligent braking heuristic
        # Condition 1: Need to brake for an upcoming turn
        # We need to brake if our current speed is too high for the upcoming critical point,
        # AND we are within the braking distance for that point.
        # Add a small buffer to distance_to_critical_point to brake slightly early
        braking_buffer = dt * car_velocity * 0.5 # A small distance equivalent to half a time step travel

        if car_velocity > min_speed_in_lookahead and required_braking_distance >= (distance_to_critical_point - braking_buffer):
            target_acceleration = -max_braking_deceleration
        # Condition 2: Accelerate if currently below the allowed speed for the current point and not braking for a future point
        elif car_velocity < current_max_allowed_speed_at_point:
            target_acceleration = max_acceleration
        # Condition 3: If neither braking for an upcoming turn nor accelerating for current point, then coast (target_acceleration remains 0)
        # This covers scenarios where car_velocity is between min_speed_in_lookahead and current_max_allowed_speed_at_point,
        # and we are not yet at the braking point for the upcoming critical speed.

        # Calculate drag force (proportional to velocity squared)
        drag_force = drag_coefficient * car_velocity**2

        # Apply drag force to the acceleration
        car_acceleration = target_acceleration - drag_force

        # Clamp car_acceleration to respect max_acceleration limits
        # For now, we should accept that drag helps max_deceleration! (max_acceleration is for positive acceleration)
        # If target_acceleration is -max_braking_deceleration, the actual deceleration can be greater due to drag
        if target_acceleration >= 0: # Accelerating or coasting
            car_acceleration = min(car_acceleration, max_acceleration)
        else: # Braking
            # Ensure effective deceleration is not less than max_braking_deceleration (i.e. not accelerating)
            car_acceleration = max(car_acceleration, -max_braking_deceleration)

        # Update car_velocity
        car_velocity += car_acceleration * dt
        # Clamp car_velocity to be non-negative (can't go backwards) and not exceed max_base_speed for safety
        car_velocity = max(0.0, min(car_velocity, max_base_speed))

        # Calculate distance moved in this frame
        distance_moved = car_velocity * dt

        # Update car's odometer
        car_odometer_distance += distance_moved

        # Lap counting logic: A lap is completed when car_odometer_distance exceeds a full track length
        laps_covered_by_distance = int(car_odometer_distance // total_track_length)

        if laps_covered_by_distance > laps_recorded:
            # A full lap has been completed.
            current_frame_time = frame * dt
            lap_duration = current_frame_time - last_lap_completion_time
            lap_durations.append(lap_duration)
            lap_completion_frames.append(frame)
            print(f"Lap {laps_recorded + 1} completed in {lap_duration:.2f} seconds (frame {frame})")
            last_lap_completion_time = current_frame_time
            laps_recorded = laps_covered_by_distance

        # Calculate precise (x,y) on spline based on car's current position on the track loop
        current_car_x, current_car_y = splev(np.interp(current_pos_on_loop, cumulative_path_length, u_fine), tck)

        car_x_points.append(current_car_x)
        car_y_points.append(current_car_y)
        car_velocities_history.append(car_velocity)
        car_headings_history.append(headings_deg[car_current_index]) # Store heading

    return car_x_points, car_y_points, car_velocities_history, car_headings_history, lap_durations, lap_completion_frames

"""### Loading/caching"""

# Get geometry data for the current filename
geometry_data = tracks_data[filename]['geometry']

# Create a dictionary of physics parameters for caching
physics_params = {
    'dt': dt,
    'max_base_speed': max_base_speed,
    'min_curve_speed_factor': min_curve_speed_factor,
    'min_speed_ratio': min_speed_ratio,
    'max_acceleration': max_acceleration,
    'max_braking_deceleration': max_braking_deceleration,
    'drag_coefficient': drag_coefficient,
    'lookahead_distance_factor': 2.0 # Updated: Use a dynamic lookahead based on distance
}

sim_cache_key = generate_sim_cache_key(physics_params, filename)

# Check if simulation results are cached
if not redo_simulation and sim_cache_key in tracks_data[filename]['simulation_results']:
    print("Loading simulation results from cache...")
    cached_sim_results = tracks_data[filename]['simulation_results'][sim_cache_key]
    trajectory_x = cached_sim_results['x']
    trajectory_y = cached_sim_results['y']
    trajectory_velocities = cached_sim_results['velocities']
    trajectory_headings = cached_sim_results['headings'] # retrieve headings
    final_lap_durations = cached_sim_results['lap_durations']
    final_lap_completion_frames = cached_sim_results['lap_completion_frames']
else:
    print("Simulating car trajectory...")
    trajectory_x, trajectory_y, trajectory_velocities, trajectory_headings, final_lap_durations, final_lap_completion_frames = simulate_car_trajectory(geometry_data, physics_params) # capture headings

    # Store results in cache
    tracks_data[filename]['simulation_results'][sim_cache_key] = {
        'x': trajectory_x,
        'y': trajectory_y,
        'velocities': trajectory_velocities,
        'headings': trajectory_headings,
        'lap_durations': final_lap_durations,
        'lap_completion_frames': final_lap_completion_frames
    }
    print(f"Simulation completed. Cached with key: {sim_cache_key}")

"""### Animation updating function"""

def update(frame, car_artist, text_artist_speed, text_artist_lap, traj_x, traj_y, traj_velocities, traj_headings, lap_durations_data, lap_completion_frames_data, ax_transform):
    current_car_x = traj_x[frame]
    current_car_y = traj_y[frame]
    current_car_velocity = traj_velocities[frame]
    current_car_heading = traj_headings[frame]

    # Update the car's position and rotation using an Affine2D transform
    transform = Affine2D().rotate_deg(current_car_heading) + Affine2D().translate(current_car_x, current_car_y) + ax_transform
    car_artist.set_transform(transform)

    text_artist_speed.set_text(f'Speed: {current_car_velocity:.2f} units/s')

    # Find the most recent lap completed by the current frame
    current_lap_duration_to_display = None
    current_lap_number_to_display = 0
    for i, completion_frame in enumerate(lap_completion_frames_data):
        if frame >= completion_frame:
            current_lap_duration_to_display = lap_durations_data[i]
            current_lap_number_to_display = i + 1
        else:
            break # Laps are ordered by completion_frame, so no more laps will be completed yet

    if current_lap_duration_to_display is not None:
        text_artist_lap.set_text(f'Lap {current_lap_number_to_display}: {current_lap_duration_to_display:.2f}s')
    else:
        text_artist_lap.set_text('Laps: --')

    return car_artist, text_artist_speed, text_artist_lap

"""### Diagnostic: Velocity Profile"""

fig, ax = plt.subplots(figsize=(12, 6))

# Create a time array for the x-axis (frames * dt)
time_steps = np.arange(len(trajectory_velocities)) * dt

ax.plot(time_steps, trajectory_velocities, label='Car Velocity')
ax.set_xlabel('Time (s)')
ax.set_ylabel('Velocity (units/s)')
ax.set_title('Car Velocity Profile Over Simulation Time')
ax.grid(True, linestyle='--', alpha=0.7)
ax.legend()

plt.tight_layout()
plt.show()

"""## Animation of Model on Track"""

redo_simulation = False

# --- Animation Setup and FuncAnimation Call ---
fig, ax = plt.subplots(figsize=(8,8))
# Scale the image and set its extent
ax.imshow(img[...,::-1], extent=[0, img.shape[1] * track_scale, img.shape[0] * track_scale, 0])  # convert BGR -> RGB

# Plot the smoothed track
ax.plot(geometry_data['x_smooth'], geometry_data['y_smooth'], 'b--', linewidth=1, alpha=0.7)

# the "car" - now a rectangle patch that rotates
car_width, car_height = 50 * track_scale, 25 * track_scale # Define car size and apply track_scale
initial_x = geometry_data['x_smooth'][geometry_data['start_index']]
initial_y = geometry_data['y_smooth'][geometry_data['start_index']]
initial_heading = geometry_data['headings_deg'][geometry_data['start_index']]

# Create the rectangle with its center at (0,0), then apply transforms for position and rotation
car = patches.Rectangle(
    (-car_width / 2, -car_height / 2), # Centered at (0,0)
    car_width,
    car_height,
    facecolor='red',
    edgecolor='black',
    zorder=3 # Ensure car is drawn on top
)

# Apply initial transform to the car patch
initial_transform = Affine2D().rotate_deg(initial_heading) + Affine2D().translate(initial_x, initial_y) + ax.transData
car.set_transform(initial_transform)

ax.add_patch(car) # Add the car patch to the axes

# Add text for speed and lap time
text_speed = ax.text(0.05, 0.95, '', transform=ax.transAxes, color='black', fontsize=12, verticalalignment='top')
text_lap = ax.text(0.05, 0.90, '', transform=ax.transAxes, color='black', fontsize=12, verticalalignment='top')

# Determine number of frames for animation
num_animation_frames = len(trajectory_x)

ani = FuncAnimation(fig, update, frames=num_animation_frames, interval=20, blit=True, fargs=(
    car, text_speed, text_lap, trajectory_x, trajectory_y, trajectory_velocities, trajectory_headings,
    final_lap_durations, final_lap_completion_frames, ax.transData # Pass new lap data
))

# Close the figure to prevent it from being displayed as a static image
plt.close(fig)
print("Animation prepared.")

output_filename = f"car_physics_animation_{sim_cache_key}.html"

# Check if the animation HTML file already exists
if os.path.exists(output_filename) and not redo_simulation:
    print(f"Reusing cached animation from {output_filename}")
    with open(output_filename, "r") as f:
        animation_html = f.read()
else:
    print(f"Generating and saving animation to {output_filename}")
    # Generate the HTML string for the animation
    animation_html = ani.to_jshtml()

    # Write the HTML string to a file
    with open(output_filename, "w") as f:
        f.write(animation_html)

print("You can download this file from the Colab file browser (left sidebar -> folder icon) and open it in any web browser.")

# Display the animation in Colab
HTML(animation_html)