# -*- coding: utf-8 -*-
"""track monster.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10QSpKRW--4OrLqx_mwzGXEs_uAlOzcqS
"""

# imports
import matplotlib.pyplot as plt
import matplotlib as mpl
from matplotlib.animation import FuncAnimation
from IPython.display import HTML
from scipy.interpolate import splprep, splev
import hashlib
import os
import cv2
import numpy as np
import time
from skimage.morphology import skeletonize
from matplotlib.transforms import Affine2D
import matplotlib.patches as patches

"""### Car on a simple circular path"""

# Simple circular track
# Reduced number of points to speed up animation generation
theta = np.linspace(0, 2*np.pi, 100) # Changed from 500 to 100 points
x = 100 + 80 * np.cos(theta)
y = 100 + 80 * np.sin(theta)

fig, ax = plt.subplots(figsize=(5,5))
ax.set_xlim(0, 200)
ax.set_ylim(0, 200)

# plot track
ax.plot(x, y, color='black')

# the "car"
dot, = ax.plot([], [], 'o', color='red', markersize=8)

def update(frame, x_data, y_data, artist):
  # The print statement is commented out to avoid excessive output during animation
  artist.set_data([x_data[frame]], [y_data[frame]])
  return artist,

ani = FuncAnimation(fig, update, frames=len(x), interval=10, fargs=(x, y, dot))

# Close the figure to prevent it from being displayed as a static image
plt.close(fig)

# # Display the animation in Colab
# HTML(ani.to_jshtml())

"""### Converting a png of a track"""

tracks_data = dict()

def track_details(filename):
  if filename not in tracks_data:
    tracks_data[filename] = {
        "name": None,
        "start_index": None,
        "direction": None,
        "track_scale": None,
        "geometry": {},
        "simulation_results": {}
    }

  # Ensure geometry and simulation_results dictionaries exist
  if "geometry" not in tracks_data[filename]:
    tracks_data[filename]["geometry"] = {}
  if "simulation_results" not in tracks_data[filename]:
    tracks_data[filename]["simulation_results"] = {}

  # Update track-specific details
  if filename == "gb.png":
    tracks_data[filename]["name"] = "Silverstone"
    tracks_data[filename]["start_index"] = 471
    tracks_data[filename]["direction"] = True
    tracks_data[filename]["track_scale"] = 1.5

  # Retrieve the updated details for return
  name = tracks_data[filename]["name"]
  start_index = tracks_data[filename]["start_index"]
  direction = tracks_data[filename]["direction"]
  track_scale = tracks_data[filename]["track_scale"]

  return name, start_index, direction, track_scale

filename = "gb.png"
smoothing_factor = 15000 # smoothing factor
total_path_vertices = 1500

"""### Cache Spline, Curvature into Geometry object"""

# Step 1: Load your track image (upload into Colab first)
img = cv2.imread(filename)
trackname, start_index, track_direction, track_scale = track_details(filename)
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# Step 2: Extract edges or threshold
edges = cv2.Canny(gray, 50, 150)

# Threshold then skeletonize
_, thresh = cv2.threshold(gray, 200, 255, cv2.THRESH_BINARY_INV)
skel = skeletonize(thresh // 255)

# Step 4: Extract the path points

# Helper to find neighbors of a point (y, x) in a skeleton
def get_neighbors(skel_image, y, x):
    neighbors = []
    for dy in [-1, 0, 1]:
        for dx in [-1, 0, 1]:
            if dy == 0 and dx == 0:
                continue
            ny, nx = y + dy, x + dx
            if 0 <= ny < skel_image.shape[0] and 0 <= nx < skel_image.shape[1] and skel_image[ny, nx]:
                neighbors.append((ny, nx))
    return neighbors

# Reorder the points for spline fitting
skel_points_list = [(p[0], p[1]) for p in np.column_stack(np.where(skel > 0))]
skel_points_set = set(skel_points_list) # For efficient lookup

ordered_pts_list = []

if skel_points_list:
    # Find a starting point (e.g., an endpoint with only one neighbor, or just the first point)
    start_point = None
    for p_y, p_x in skel_points_list:
        if len(get_neighbors(skel, p_y, p_x)) == 1:
            start_point = (p_y, p_x)
            break
    if start_point is None: # If no clear endpoint (e.g. a closed loop), pick the first point
        start_point = skel_points_list[0]

    current_point = start_point
    visited = {current_point}
    ordered_pts_list.append(current_point)

    # Traverse the skeleton to order points
    while len(ordered_pts_list) < len(skel_points_list):
        neighbors = get_neighbors(skel, current_point[0], current_point[1])
        next_point = None
        for n_y, n_x in neighbors:
            neighbor_tuple = (n_y, n_x)
            if neighbor_tuple not in visited and neighbor_tuple in skel_points_set:
                next_point = neighbor_tuple
                break
        if next_point:
            ordered_pts_list.append(next_point)
            visited.add(next_point)
            current_point = next_point
        else:
            # If we get stuck (e.g., a branch or discontinuity in the skeleton), break
            # For a single continuous path, this shouldn't be reached until all points are visited
            break

# Convert ordered points back to a NumPy array
pts = np.array(ordered_pts_list)

# Apply scaling to the points BEFORE spline fitting
pts_scaled = pts * track_scale

# Sort/fit a nice smooth spline along pts
tck, u = splprep([pts_scaled[:,1], pts_scaled[:,0]], s=smoothing_factor) # Use the scaled points
u_fine = np.linspace(0, 1, total_path_vertices) # Increased to 1000 points for better curvature detail
x_smooth, y_smooth = splev(u_fine, tck)

# Calculate cumulative path length from the already scaled x_smooth, y_smooth
distances = np.sqrt(np.diff(x_smooth)**2 + np.diff(y_smooth)**2)
cumulative_path_length = np.concatenate(([0.], np.cumsum(distances)))

# Calculate derivatives for curvature and heading
dx_du, dy_du = splev(u_fine, tck, der=1)
d2x_du2, d2y_du2 = splev(u_fine, tck, der=2)

# Calculate curvature
# Note: Curvature will be 1/track_scale * original_curvature if coordinates are scaled.
# This is physically correct for a scaled track.
curvature = (dx_du * d2y_du2 - dy_du * d2x_du2) / (dx_du**2 + dy_du**2)**1.5

# Calculate heading angles (tangent to the path) in degrees
headings_rad = np.arctan2(dy_du, dx_du)
headings_deg = np.degrees(headings_rad)

# Store all resulting geometry data into tracks_data[filename]['geometry']
# x_smooth, y_smooth, cumulative_path_length are already scaled by pts_scaled
tracks_data[filename]['geometry']['x_smooth'] = x_smooth
tracks_data[filename]['geometry']['y_smooth'] = y_smooth
tracks_data[filename]['geometry']['curvature'] = curvature
tracks_data[filename]['geometry']['cumulative_path_length'] = cumulative_path_length
tracks_data[filename]['geometry']['tck'] = tck
tracks_data[filename]['geometry']['u_fine'] = u_fine
tracks_data[filename]['geometry']['start_index'] = start_index
tracks_data[filename]['geometry']['headings_deg'] = headings_deg # Store heading degrees

print(f"Geometry data for {filename} (track '{trackname}') stored in tracks_data.")

"""### Helper Visualization for Track Initialization: Display Nth Point on Spline"""

def visualize_nth_point(n_point, x_data, y_data, track_image, title="Highlighted Point on Track"):
    if not (0 <= n_point < len(x_data)):
        print(f"Error: n_point ({n_point}) is out of bounds for data of length {len(x_data)}.")
        return

    fig, ax = plt.subplots(figsize=(10, 10))
    # Scale the image extent by track_scale to match the scaled x_data, y_data
    ax.imshow(track_image[...,::-1], extent=[0, track_image.shape[1] * track_scale, track_image.shape[0] * track_scale, 0])

    # Plot the full smoothed track
    ax.plot(x_data, y_data, 'b--', linewidth=1, alpha=0.7, label='Smoothed Track')

    # Highlight the nth point
    ax.plot(x_data[n_point], y_data[n_point], 'o', color='magenta', markersize=12, label=f'Point {n_point}', zorder=3)

    ax.set_title(title)
    ax.set_aspect('equal', adjustable='box')
    ax.legend()
    plt.show()

# Example usage: Visualize the starting point provided by track_details
# Ensure 'start_index' and 'x_smooth', 'y_smooth', 'img' are available from previous cells

# Assuming `start_index` is retrieved from `track_details` and `img` is the loaded track image
# If track_details returns 1, let's visualize index 1.
# You can change this to any index you want to inspect.

# Retrieve values from track_details
trackname_val, start_index_val, track_direction_val, track_scale_val = track_details(filename)

visualize_nth_point(start_index_val, x_smooth, y_smooth, img, title=f'Starting Point ({start_index_val}) for {trackname_val}')

# # Step 5: Animate a rectangle "car" moving along the spline
# fig, ax = plt.subplots(figsize=(6,6))
# ax.imshow(img[...,::-1])  # convert BGR -> RGB
# car, = ax.plot([], [], 's', markersize=10, color='red')

# # Define a simple update function locally for this animation
# def simple_update(frame, x_data, y_data, artist):
#   artist.set_data([x_data[frame]], [y_data[frame]])
#   return artist,

# plt.close(fig)
# ani = FuncAnimation(fig, simple_update, frames=len(x_smooth), interval=10, fargs=(x_smooth, y_smooth, car))

# HTML(ani.to_jshtml())

"""## Initialize Physics Model

"""

car_x = x_smooth[start_index]
car_y = y_smooth[start_index]
car_velocity = 0.0
car_acceleration = 0.0
dt = 0.05 # Time step for numerical integration

print(f"Car initialized at (x={car_x:.2f}, y={car_y:.2f}) with velocity={car_velocity:.2f} and acceleration={car_acceleration:.2f}. Time step dt={dt}.")

# Constants for physics model
max_base_speed = 365.0
min_curve_speed_factor = 2_000
min_speed_ratio = 0.135 # Minimum speed as a ratio of max_base_speed
max_acceleration = 52
max_braking_deceleration = 80
drag_coefficient = 0.0005
lookahead_indices = 30 # New parameter to control lookahead distance for predictive braking

def get_max_speed(current_curvature, max_base_speed, min_curve_speed_factor, min_speed_ratio):
    # Ensure curvature is positive for calculation
    abs_curvature = abs(current_curvature)

    # Use a non-linear term to adjust speed based on curvature
    # Power > 1 makes it less punitive at low curvature, more punitive at high curvature
    max_speed_unbounded = max_base_speed / (1 + abs_curvature**1.8 * min_curve_speed_factor)

    # Apply a minimum speed limit to prevent the car from stopping entirely
    max_speed = max(max_speed_unbounded, max_base_speed * min_speed_ratio)
    return max_speed

"""## Theoretical Acceleration and Braking Times (Factoring in Drag)"""

import numpy as np

# Target speed for acceleration/braking test
target_speed = 300.0 # units/second

# --- Acceleration with Drag ---
# dv/dt = max_acceleration - drag_coefficient * v^2
# Integral of dv / (a - c*v^2) from 0 to target_speed
# Result is 1/(2*sqrt(ac)) * ln |(sqrt(a) + v*sqrt(c)) / (sqrt(a) - v*sqrt(c))|

a = max_acceleration
c = drag_coefficient

# Check for potential division by zero or negative argument in sqrt/log
if a * c <= 0 or (np.sqrt(a) - target_speed * np.sqrt(c)) <= 0:
    print("Cannot calculate acceleration time with drag using this formula (parameters lead to singularity or imaginary numbers).")
    print("This could mean target_speed is too high for given max_acceleration and drag, or parameters are zero.")
    time_to_accelerate_drag = np.inf
else:
    term_sqrt_ac = np.sqrt(a * c)
    term_sqrt_a = np.sqrt(a)
    term_sqrt_c = np.sqrt(c)

    # Ensure the argument for log is positive
    numerator = term_sqrt_a + target_speed * term_sqrt_c
    denominator = term_sqrt_a - target_speed * term_sqrt_c

    if denominator <= 0: # This means the car cannot reach target_speed due to drag limiting top speed
        print(f"Warning: Car's top speed ({term_sqrt_a / term_sqrt_c:.2f} units/s) is less than target_speed ({target_speed:.2f} units/s) with current drag/acceleration.")
        time_to_accelerate_drag = np.inf # Car can't reach this speed
    else:
        time_to_accelerate_drag = (1 / (2 * term_sqrt_ac)) * np.log(numerator / denominator)


# --- Braking with Drag ---
# dv/dt = -max_braking_deceleration - drag_coefficient * v^2
# Integral of -dv / (d + c*v^2) from target_speed to 0
# Result is 1/sqrt(dc) * (arctan(v0*sqrt(c/d)) - arctan(vf*sqrt(c/d)))
# For braking to 0, vf=0, so arctan(0) = 0.

d = max_braking_deceleration
c = drag_coefficient

if d * c <= 0:
    print("Cannot calculate braking time with drag using this formula (parameters lead to singularity). Parameters might be zero.")
    time_to_brake_drag = np.inf
else:
    term_sqrt_dc = np.sqrt(d * c)
    term_sqrt_c_div_d = np.sqrt(c / d)
    time_to_brake_drag = (1 / term_sqrt_dc) * np.arctan(target_speed * term_sqrt_c_div_d)

print(f"Time to accelerate from 0 to {target_speed:.2f} units/s (with drag): {time_to_accelerate_drag:.2f} seconds")
print(f"Time to brake from {target_speed:.2f} units/s to 0 (with drag): {time_to_brake_drag:.2f} seconds")

# For comparison, re-print values without drag (from cell be7cdcf9)
# time_to_accelerate_no_drag = target_speed / max_acceleration
# time_to_brake_no_drag = target_speed / max_braking_deceleration
# print(f"For comparison, without drag: Acceleration Time: {time_to_accelerate_no_drag:.2f}s, Braking Time: {time_to_brake_no_drag:.2f}s")

"""## Max speed vs curvature"""

# --- Plotting the sample curvatures vs speeds ---
curvature_range = np.linspace(0, 0.04, 1000) # From 0 to 0.05 with 500 points

# Calculate max speed for each curvature in the range
max_speeds_for_range = [
    get_max_speed(curv, max_base_speed, min_curve_speed_factor, min_speed_ratio)
    for curv in curvature_range
]

fig, ax = plt.subplots(figsize=(12, 6))

ax.plot(curvature_range, max_speeds_for_range, linestyle='-', color='blue')

min_allowed_speed = min_speed_ratio * max_base_speed
ax.axhline(y=min_allowed_speed, color='red', linestyle='--', label=f'Min Allowed Speed ({min_allowed_speed:.2f})')

ax.set_xlabel('Curvature Magnitude')
ax.set_ylabel('Maximum Allowed Speed (units/s)')
ax.set_title(f'Maximum Allowed Speed vs. Curvature (min_curve_speed_factor={min_curve_speed_factor})')
ax.grid(True, linestyle='--', alpha=0.7)

plt.tight_layout()
plt.show()
# --- End plotting ---

"""## Visualize Track Curvature"""

import matplotlib.colors as mcolors

# Calculate anticipated max speed for each point based on the lookahead window
# This replicates the predictive braking logic for visualization.
anticipated_max_speeds_for_plotting = []
num_track_points = len(tracks_data[filename]['geometry']['curvature'])

for i in range(num_track_points):
    lookahead_window_start = i
    lookahead_window_end = min(i + lookahead_indices, num_track_points)

    # Handle wrap-around for a continuous track in lookahead if needed,
    # but for simplicity, we'll cap at the end for static visualization.
    lookahead_curvatures = tracks_data[filename]['geometry']['curvature'][lookahead_window_start:lookahead_window_end]

    if len(lookahead_curvatures) == 0: # Should not happen if lookahead_indices is reasonable
        max_speed_in_window = get_max_speed(tracks_data[filename]['geometry']['curvature'][i], max_base_speed, min_curve_speed_factor, min_speed_ratio)
    else:
        max_speeds_in_window = [
            get_max_speed(c, max_base_speed, min_curve_speed_factor, min_speed_ratio)
            for c in lookahead_curvatures
        ]
        max_speed_in_window = np.min(max_speeds_in_window)

    anticipated_max_speeds_for_plotting.append(max_speed_in_window)

anticipated_max_speeds_for_plotting = np.array(anticipated_max_speeds_for_plotting)

# Choose a colormap: 'RdYlGn' (Red-Yellow-Green) is good, with Red for low speed, Green for high speed.
cmap = plt.cm.get_cmap('RdYlGn')

fig, ax = plt.subplots(figsize=(10, 10))
ax.imshow(img[...,::-1], extent=[0, img.shape[1] * track_scale, img.shape[0] * track_scale, 0])

# Plot the track points, colored by anticipated maximum allowed speed with linear scale
scatter = ax.scatter(
    x_smooth, y_smooth,
    c=anticipated_max_speeds_for_plotting,
    cmap=cmap,
    s=20,
    zorder=2
)

ax.set_title('Track Anticipated Max Speed Visualization (Red=Low Speed, Green=High Speed)')
ax.set_aspect('equal', adjustable='box')

# Add a colorbar
cbar = fig.colorbar(scatter, ax=ax, orientation='vertical', fraction=0.046, pad=0.04)
cbar.set_label('Anticipated Maximum Allowed Speed (units/s)')

plt.show()

"""## Track Curvature Magnitude Plot"""

import matplotlib.pyplot as plt
import numpy as np

# Assuming 'curvature' array is available from previous cells
# Use absolute curvature to represent magnitude
abs_curvature = np.abs(tracks_data[filename]['geometry']['curvature'])

fig, ax = plt.subplots(figsize=(15, 6))

# Plot curvature magnitude against point index
ax.plot(abs_curvature)

ax.set_xlabel('Track Point Index')
ax.set_ylabel('Absolute Curvature Magnitude')
ax.set_title('Track Curvature Magnitude Across Points')
ax.grid(True, linestyle='--', alpha=0.7)

plt.tight_layout()
plt.show()

mpl.rcParams['animation.embed_limit'] = 300.0 # Raise to 300 MB
redo_simulation = True # Ensure simulation is re-run with new logic

# --- Helper Functions for Caching and Simulation ---

def generate_sim_cache_key(physics_params):
    # Convert physics_params dictionary to a sorted string for consistent hashing
    sorted_params = sorted(physics_params.items())
    params_str = str(sorted_params)
    return hashlib.sha256(params_str.encode('utf-8')).hexdigest()

def simulate_car_trajectory(geometry_data, physics_params, num_frames=2500):
    # Extract geometry data
    x_smooth = geometry_data['x_smooth']
    y_smooth = geometry_data['y_smooth']
    curvature = geometry_data['curvature']
    cumulative_path_length = geometry_data['cumulative_path_length']
    tck = geometry_data['tck']
    u_fine = geometry_data['u_fine']
    start_index = geometry_data['start_index']
    headings_deg = geometry_data['headings_deg'] # New: Extract heading degrees
    total_track_length = cumulative_path_length[-1]

    # Extract physics parameters
    dt = physics_params['dt']
    max_base_speed = physics_params['max_base_speed']
    min_curve_speed_factor = physics_params['min_curve_speed_factor']
    min_speed_ratio = physics_params['min_speed_ratio']
    max_acceleration = physics_params['max_acceleration']
    max_braking_deceleration = physics_params['max_braking_deceleration']
    drag_coefficient = physics_params['drag_coefficient']
    lookahead_indices = physics_params['lookahead_indices'] # New parameter to control lookahead distance for predictive braking

    # Initialize local simulation state variables
    car_x_points = []
    car_y_points = []
    car_velocities_history = []
    car_headings_history = [] # Store car heading at each frame
    lap_durations = [] # Store lap durations
    lap_completion_frames = [] # Store the frame index when each lap was completed

    # Car state variables
    car_odometer_distance = 0.0 # Total distance traveled by the car since the start of simulation
    car_velocity = 0.0
    car_acceleration = 0.0

    # Lap timing specific variables
    # We define the start line as the position corresponding to start_index
    start_line_absolute_position = cumulative_path_length[start_index]
    last_lap_completion_time = 0.0 # Time when the last lap was completed
    laps_recorded = 0

    # Simulation loop
    for frame in range(num_frames):
        # Calculate current position on the track loop based on odometer and initial start_index offset
        # This ensures the car's position on the track accurately reflects a continuous loop
        current_pos_on_loop = (start_line_absolute_position + car_odometer_distance) % total_track_length

        # Find the new_car_current_index for curvature (nearest point on discrete path)
        new_car_current_index = np.searchsorted(cumulative_path_length, current_pos_on_loop, side='right') - 1
        car_current_index = max(0, min(new_car_current_index, len(x_smooth) - 1))

        # Get current curvature at the car's position
        current_curvature = curvature[car_current_index]

        # --- Predictive Braking Logic ---
        # Calculate minimum allowed speed within a lookahead window
        lookahead_window_start = car_current_index
        # Ensure lookahead wraps around the track if near the end
        lookahead_curvatures_list = []
        for k in range(lookahead_indices):
            idx = (lookahead_window_start + k) % len(curvature)
            lookahead_curvatures_list.append(curvature[idx])
        lookahead_curvatures = np.array(lookahead_curvatures_list)

        # If the lookahead window is empty (should not happen with good lookahead_indices), default to current curvature
        if len(lookahead_curvatures) == 0: # Should not happen if lookahead_indices is reasonable
            max_speed_in_lookahead = get_max_speed(current_curvature, max_base_speed, min_curve_speed_factor, min_speed_ratio)
        else:
            # Calculate max allowed speed for each point in the lookahead window
            max_speeds_in_window = [
                get_max_speed(c, max_base_speed, min_curve_speed_factor, min_speed_ratio)
                for c in lookahead_curvatures
            ]
            # The minimum of these is the speed limit the car should anticipate
            max_speed_in_lookahead = np.min(max_speeds_in_window)

        # Determine desired acceleration based on current and predictive max speeds
        target_acceleration = 0.0

        # If car is currently faster than the upcoming speed limit, brake
        if car_velocity > max_speed_in_lookahead:
            target_acceleration = -max_braking_deceleration
        # Otherwise, accelerate up to the current max allowed speed (which might be higher than lookahead_speed)
        elif car_velocity < get_max_speed(current_curvature, max_base_speed, min_curve_speed_factor, min_speed_ratio):
            target_acceleration = max_acceleration

        # Calculate drag force (proportional to velocity squared)
        drag_force = drag_coefficient * car_velocity**2

        # Apply drag force to the acceleration
        car_acceleration = target_acceleration - drag_force

        # Clamp car_acceleration to respect max_acceleration limits
        # For now, we should accept that drag helps max_deceleration!
        car_acceleration = min(car_acceleration, max_acceleration)

        # Update car_velocity
        car_velocity += car_acceleration * dt
        # Clamp car_velocity to be non-negative (can't go backwards) and not exceed max_base_speed for safety
        car_velocity = max(0.0, min(car_velocity, max_base_speed))

        # Calculate distance moved in this frame
        distance_moved = car_velocity * dt

        # Update car's odometer
        car_odometer_distance += distance_moved

        # Lap counting logic: A lap is completed when car_odometer_distance exceeds a full track length
        laps_covered_by_distance = int(car_odometer_distance // total_track_length)

        if laps_covered_by_distance > laps_recorded:
            # A full lap has been completed.
            current_frame_time = frame * dt
            lap_duration = current_frame_time - last_lap_completion_time
            lap_durations.append(lap_duration)
            lap_completion_frames.append(frame)
            print(f"Lap {laps_recorded + 1} completed in {lap_duration:.2f} seconds (frame {frame})")
            last_lap_completion_time = current_frame_time
            laps_recorded = laps_covered_by_distance

        # Calculate precise (x,y) on spline based on car's current position on the track loop
        current_car_x, current_car_y = splev(np.interp(current_pos_on_loop, cumulative_path_length, u_fine), tck)

        car_x_points.append(current_car_x)
        car_y_points.append(current_car_y)
        car_velocities_history.append(car_velocity)
        car_headings_history.append(headings_deg[car_current_index]) # Store heading

    return car_x_points, car_y_points, car_velocities_history, car_headings_history, lap_durations, lap_completion_frames

# --- Simulation Caching Logic ---

# Get geometry data for the current filename
geometry_data = tracks_data[filename]['geometry']

# Create a dictionary of physics parameters for caching
physics_params = {
    'dt': dt,
    'max_base_speed': max_base_speed,
    'min_curve_speed_factor': min_curve_speed_factor,
    'min_speed_ratio': min_speed_ratio,
    'max_acceleration': max_acceleration,
    'max_braking_deceleration': max_braking_deceleration,
    'drag_coefficient': drag_coefficient,
    'lookahead_indices': lookahead_indices
}

sim_cache_key = generate_sim_cache_key(physics_params)

# Check if simulation results are cached
if not redo_simulation and sim_cache_key in tracks_data[filename]['simulation_results']:
    print("Loading simulation results from cache...")
    cached_sim_results = tracks_data[filename]['simulation_results'][sim_cache_key]
    trajectory_x = cached_sim_results['x']
    trajectory_y = cached_sim_results['y']
    trajectory_velocities = cached_sim_results['velocities']
    trajectory_headings = cached_sim_results['headings'] # retrieve headings
    final_lap_durations = cached_sim_results['lap_durations']
    final_lap_completion_frames = cached_sim_results['lap_completion_frames']
else:
    print("Simulating car trajectory...")
    trajectory_x, trajectory_y, trajectory_velocities, trajectory_headings, final_lap_durations, final_lap_completion_frames = simulate_car_trajectory(geometry_data, physics_params) # capture headings

    # Store results in cache
    tracks_data[filename]['simulation_results'][sim_cache_key] = {
        'x': trajectory_x,
        'y': trajectory_y,
        'velocities': trajectory_velocities,
        'headings': trajectory_headings,
        'lap_durations': final_lap_durations,
        'lap_completion_frames': final_lap_completion_frames
    }
    print(f"Simulation completed. Cached with key: {sim_cache_key}")

# --- Simplified Update Function for Animation ---

def update(frame, car_artist, text_artist_speed, text_artist_lap, traj_x, traj_y, traj_velocities, traj_headings, lap_durations_data, lap_completion_frames_data, ax_transform):
    current_car_x = traj_x[frame]
    current_car_y = traj_y[frame]
    current_car_velocity = traj_velocities[frame]
    current_car_heading = traj_headings[frame]

    # Update the car's position and rotation using an Affine2D transform
    transform = Affine2D().rotate_deg(current_car_heading) + Affine2D().translate(current_car_x, current_car_y) + ax_transform
    car_artist.set_transform(transform)

    text_artist_speed.set_text(f'Speed: {current_car_velocity:.2f} units/s')

    # Find the most recent lap completed by the current frame
    current_lap_duration_to_display = None
    current_lap_number_to_display = 0
    for i, completion_frame in enumerate(lap_completion_frames_data):
        if frame >= completion_frame:
            current_lap_duration_to_display = lap_durations_data[i]
            current_lap_number_to_display = i + 1
        else:
            break # Laps are ordered by completion_frame, so no more laps will be completed yet

    if current_lap_duration_to_display is not None:
        text_artist_lap.set_text(f'Lap {current_lap_number_to_display}: {current_lap_duration_to_display:.2f}s')
    else:
        text_artist_lap.set_text('Laps: --')

    return car_artist, text_artist_speed, text_artist_lap

"""## Car Speed Profile Over Time (pre-animation sanity check)"""

fig, ax = plt.subplots(figsize=(12, 6))

# Create a time array for the x-axis (frames * dt)
time_steps = np.arange(len(trajectory_velocities)) * dt

ax.plot(time_steps, trajectory_velocities, label='Car Velocity')
ax.set_xlabel('Time (s)')
ax.set_ylabel('Velocity (units/s)')
ax.set_title('Car Velocity Profile Over Simulation Time')
ax.grid(True, linestyle='--', alpha=0.7)
ax.legend()

plt.tight_layout()
plt.show()

"""## Animation of Physics Model on Track"""

redo_simulation = False

# --- Animation Setup and FuncAnimation Call ---
fig, ax = plt.subplots(figsize=(8,8))
# Scale the image and set its extent
ax.imshow(img[...,::-1], extent=[0, img.shape[1] * track_scale, img.shape[0] * track_scale, 0])  # convert BGR -> RGB

# Plot the smoothed track
ax.plot(geometry_data['x_smooth'], geometry_data['y_smooth'], 'b--', linewidth=1, alpha=0.7)

# the "car" - now a rectangle patch that rotates
car_width, car_height = 50 * track_scale, 25 * track_scale # Define car size and apply track_scale
initial_x = geometry_data['x_smooth'][geometry_data['start_index']]
initial_y = geometry_data['y_smooth'][geometry_data['start_index']]
initial_heading = geometry_data['headings_deg'][geometry_data['start_index']]

# Create the rectangle with its center at (0,0), then apply transforms for position and rotation
car = patches.Rectangle(
    (-car_width / 2, -car_height / 2), # Centered at (0,0)
    car_width,
    car_height,
    facecolor='red',
    edgecolor='black',
    zorder=3 # Ensure car is drawn on top
)

# Apply initial transform to the car patch
initial_transform = Affine2D().rotate_deg(initial_heading) + Affine2D().translate(initial_x, initial_y) + ax.transData
car.set_transform(initial_transform)

ax.add_patch(car) # Add the car patch to the axes

# Add text for speed and lap time
text_speed = ax.text(0.05, 0.95, '', transform=ax.transAxes, color='black', fontsize=12, verticalalignment='top')
text_lap = ax.text(0.05, 0.90, '', transform=ax.transAxes, color='black', fontsize=12, verticalalignment='top')

# Determine number of frames for animation
num_animation_frames = len(trajectory_x)

ani = FuncAnimation(fig, update, frames=num_animation_frames, interval=20, blit=True, fargs=(
    car, text_speed, text_lap, trajectory_x, trajectory_y, trajectory_velocities, trajectory_headings,
    final_lap_durations, final_lap_completion_frames, ax.transData # Pass new lap data
))

# Close the figure to prevent it from being displayed as a static image
plt.close(fig)
print("Animation prepared.")

output_filename = f"car_physics_animation_{sim_cache_key}.html"

# Check if the animation HTML file already exists
if os.path.exists(output_filename) and not redo_simulation:
    print(f"Reusing cached animation from {output_filename}")
    with open(output_filename, "r") as f:
        animation_html = f.read()
else:
    print(f"Generating and saving animation to {output_filename}")
    # Generate the HTML string for the animation
    animation_html = ani.to_jshtml()

    # Write the HTML string to a file
    with open(output_filename, "w") as f:
        f.write(animation_html)

print("You can download this file from the Colab file browser (left sidebar -> folder icon) and open it in any web browser.")

# Display the animation in Colab
HTML(animation_html)